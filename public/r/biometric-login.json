{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "biometric-login",
  "type": "registry:component",
  "title": "Biometric Login",
  "description": "A component for biometric login",
  "registryDependencies": [
    "button"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/biometric-login/login-button.tsx",
      "content": "\"use client\"\n\nimport { handleAuthentication, isWebAuthnSupported } from \"@/registry/new-york/blocks/biometric-login/lib/webauthn\"\nimport type { AuthenticationStatus } from \"@/registry/new-york/blocks/biometric-login/lib/webauthn-types\"\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport { FingerprintIcon, LoaderCircleIcon } from \"lucide-react\"\nimport { useEffect, useState } from \"react\"\n\ntype LoginButtonProps = {\n    authenticateUrl?: string\n    verifyUrl?: string\n    username?: string\n    onStatusChange?: (status: AuthenticationStatus) => void\n    onAuthenticationSuccess?: (credential: Credential | null) => void\n    onError?: (error: Error) => void\n    disabled?: boolean\n}\n\nexport function LoginButton({\n    authenticateUrl,\n    verifyUrl,\n    username = \"user@example.com\",\n    onStatusChange,\n    onAuthenticationSuccess,\n    onError,\n    disabled = false\n}: LoginButtonProps) {\n    const [isAuthenticating, setIsAuthenticating] = useState(false)\n    const [isSupported, setIsSupported] = useState<boolean>(false)\n    const [isCheckingSupport, setIsCheckingSupport] = useState(true)\n\n    useEffect(() => {\n        const checkSupport = async () => {\n            try {\n                setIsCheckingSupport(true)\n                const supported = isWebAuthnSupported()\n                setIsSupported(supported)\n\n                if (!supported) {\n                    const error = new Error(\"Biometric authentication is not supported in your browser. Please try a different browser or device.\")\n                    onError?.(error)\n                }\n            } finally {\n                setIsCheckingSupport(false)\n            }\n        }\n\n        checkSupport()\n    }, [onError])\n\n    const handleClick = async () => {\n        if (!isSupported) return\n\n        try {\n            setIsAuthenticating(true)\n\n            if (authenticateUrl && verifyUrl) {\n                await handleAuthentication(\n                    authenticateUrl,\n                    verifyUrl,\n                    username,\n                    (status) => {\n                        onStatusChange?.(status)\n                    },\n                    (credential) => {\n                        onAuthenticationSuccess?.(credential)\n                    },\n                    (error) => {\n                        onError?.(error)\n                    }\n                )\n            } else {\n                // Direct authentication without challenge\n                const credential = await navigator.credentials.get({\n                    publicKey: {\n                        challenge: new Uint8Array(32),\n                        rpId: window.location.hostname,\n                        allowCredentials: [],\n                        userVerification: \"required\",\n                    }\n                })\n                onAuthenticationSuccess?.(credential)\n            }\n        } catch (error) {\n            console.error(\"Authentication error:\", error)\n            onError?.(error instanceof Error ? error : new Error(\"An unexpected error occurred during authentication\"))\n        } finally {\n            setIsAuthenticating(false)\n        }\n    }\n\n    return (\n        <Button\n            onClick={handleClick}\n            className=\"w-full\"\n            disabled={disabled || !isSupported || isCheckingSupport}\n            aria-label=\"Sign in with biometrics\"\n        >\n            {isCheckingSupport ? (\n                <>\n                    <LoaderCircleIcon className=\"mr-2 h-4 w-4 animate-spin\" />\n                    Checking support...\n                </>\n            ) : isAuthenticating ? (\n                <>\n                    <LoaderCircleIcon className=\"mr-2 h-4 w-4 animate-spin\" />\n                    Verifying...\n                </>\n            ) : (\n                <>\n                    <FingerprintIcon className=\"mr-2 h-4 w-4\" />\n                    Sign in with Biometrics\n                </>\n            )}\n        </Button>\n    )\n} ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/biometric-login/register-button.tsx",
      "content": "\"use client\"\n\nimport { handleRegistration, isWebAuthnSupported } from \"@/registry/new-york/blocks/biometric-login/lib/webauthn\"\nimport type { AuthenticationStatus } from \"@/registry/new-york/blocks/biometric-login/lib/webauthn-types\"\nimport { Button } from \"@/registry/new-york/ui/button\"\nimport { FingerprintIcon, LoaderCircleIcon } from \"lucide-react\"\nimport { useEffect, useState } from \"react\"\n\ntype RegisterButtonProps = {\n    registerUrl?: string\n    verifyUrl?: string\n    username?: string\n    displayName?: string\n    onStatusChange?: (status: AuthenticationStatus) => void\n    onRegistrationSuccess?: (credential: Credential | null) => void\n    onError?: (error: Error) => void\n    disabled?: boolean\n}\n\nexport function RegisterButton({\n    registerUrl,\n    verifyUrl,\n    username = \"user@example.com\",\n    displayName = \"User\",\n    onStatusChange,\n    onRegistrationSuccess,\n    onError,\n    disabled = false\n}: RegisterButtonProps) {\n    const [isRegistering, setIsRegistering] = useState(false)\n    const [isSupported, setIsSupported] = useState<boolean>(false)\n    const [isCheckingSupport, setIsCheckingSupport] = useState(true)\n\n    useEffect(() => {\n        const checkSupport = async () => {\n            try {\n                setIsCheckingSupport(true)\n                const supported = isWebAuthnSupported()\n                setIsSupported(supported)\n\n                if (!supported) {\n                    const error = new Error(\"Biometric authentication is not supported in your browser. Please try a different browser or device.\")\n                    onError?.(error)\n                }\n            } finally {\n                setIsCheckingSupport(false)\n            }\n        }\n\n        checkSupport()\n    }, [onError])\n\n    const handleClick = async () => {\n        if (!isSupported) return\n\n        try {\n            setIsRegistering(true)\n\n            if (registerUrl && verifyUrl) {\n                await handleRegistration(\n                    registerUrl,\n                    verifyUrl,\n                    username,\n                    onStatusChange,\n                    onRegistrationSuccess,\n                    onError\n                )\n            } else {\n                // Direct registration without challenge\n                const credential = await navigator.credentials.create({\n                    publicKey: {\n                        rp: {\n                            name: \"WebAuthn Demo\",\n                            id: window.location.hostname,\n                        },\n                        user: {\n                            id: new Uint8Array(16),\n                            name: username,\n                            displayName: displayName,\n                        },\n                        pubKeyCredParams: [\n                            { type: \"public-key\", alg: -7 },  // ES256\n                            { type: \"public-key\", alg: -257 }, // RS256\n                        ],\n                        authenticatorSelection: {\n                            authenticatorAttachment: \"platform\",\n                            userVerification: \"required\",\n                            requireResidentKey: false,\n                        },\n                        attestation: \"none\",\n                        challenge: new Uint8Array(32),\n                    }\n                })\n                onStatusChange?.(\"success\")\n                onRegistrationSuccess?.(credential)\n            }\n        } catch (error) {\n            console.error(\"Registration error:\", error)\n            onStatusChange?.(\"error\")\n            onError?.(error instanceof Error ? error : new Error(\"An unexpected error occurred during registration\"))\n        } finally {\n            setIsRegistering(false)\n        }\n    }\n\n    return (\n        <Button\n            onClick={handleClick}\n            className=\"w-full\"\n            disabled={disabled || !isSupported || isCheckingSupport}\n            aria-label=\"Register biometric credentials\"\n        >\n            {isCheckingSupport ? (\n                <>\n                    <LoaderCircleIcon className=\"mr-2 h-4 w-4 animate-spin\" />\n                    Checking support...\n                </>\n            ) : isRegistering ? (\n                <>\n                    <LoaderCircleIcon className=\"mr-2 h-4 w-4 animate-spin\" />\n                    Registering...\n                </>\n            ) : (\n                <>\n                    <FingerprintIcon className=\"mr-2 h-4 w-4\" />\n                    Register Biometrics\n                </>\n            )}\n        </Button>\n    )\n} ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/biometric-login/lib/webauthn-types.ts",
      "content": "// WebAuthn related types\nexport type AuthenticationStatus = \"idle\" | \"authenticating\" | \"success\" | \"error\"\n\nexport interface PublicKeyCredentialCreationOptions {\n    challenge: BufferSource\n    rp: {\n        name: string\n        id?: string\n    }\n    user: {\n        id: BufferSource\n        name: string\n        displayName: string\n    }\n    pubKeyCredParams: {\n        type: \"public-key\"\n        alg: number\n    }[]\n    timeout?: number\n    excludeCredentials?: {\n        id: BufferSource\n        type: \"public-key\"\n        transports?: string[]\n    }[]\n    authenticatorSelection?: {\n        authenticatorAttachment?: \"platform\" | \"cross-platform\"\n        requireResidentKey?: boolean\n        userVerification?: \"required\" | \"preferred\" | \"discouraged\"\n    }\n    attestation?: \"none\" | \"indirect\" | \"direct\"\n}\n\nexport interface PublicKeyCredentialRequestOptions {\n    challenge: BufferSource\n    timeout?: number\n    rpId?: string\n    allowCredentials?: {\n        id: BufferSource\n        type: \"public-key\"\n        transports?: string[]\n    }[]\n    userVerification?: \"required\" | \"preferred\" | \"discouraged\"\n}\n\nexport interface PublicKeyCredentialCreationOptionsJSON {\n    challenge: string\n    rp: {\n        name: string\n        id?: string\n    }\n    user: {\n        id: string\n        name: string\n        displayName: string\n    }\n    pubKeyCredParams: Array<{\n        type: \"public-key\"\n        alg: number\n    }>\n    timeout?: number\n    attestation?: \"none\" | \"indirect\" | \"direct\"\n    authenticatorSelection?: {\n        authenticatorAttachment?: \"platform\" | \"cross-platform\"\n        requireResidentKey?: boolean\n        userVerification?: \"required\" | \"preferred\" | \"discouraged\"\n    }\n}\n\nexport interface PublicKeyCredentialRequestOptionsJSON {\n    challenge: string\n    timeout?: number\n    rpId?: string\n    allowCredentials?: Array<{\n        type: \"public-key\"\n        id: string\n        transports?: Array<\"usb\" | \"nfc\" | \"ble\" | \"internal\">\n    }>\n    userVerification?: \"required\" | \"preferred\" | \"discouraged\"\n}\n\nexport interface CredentialCreationResponse {\n    id: string\n    rawId: string\n    response: {\n        attestationObject: string\n        clientDataJSON: string\n    }\n    type: \"public-key\"\n}\n\nexport interface CredentialRequestResponse {\n    id: string\n    rawId: string\n    response: {\n        authenticatorData: string\n        clientDataJSON: string\n        signature: string\n        userHandle?: string\n    }\n    type: \"public-key\"\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/biometric-login/lib/webauthn.ts",
      "content": "import type { AuthenticationStatus, PublicKeyCredentialRequestOptions } from \"./webauthn-types\"\n\n/**\n * Convert a base64 string to an ArrayBuffer\n */\nfunction base64ToArrayBuffer(base64: string): ArrayBuffer {\n    const binaryString = window.atob(base64.replace(/-/g, \"+\").replace(/_/g, \"/\"))\n    const bytes = new Uint8Array(binaryString.length)\n    for (let i = 0; i < binaryString.length; i++) {\n        bytes[i] = binaryString.charCodeAt(i)\n    }\n    return bytes.buffer\n}\n\n/**\n * Convert an ArrayBuffer to a base64 string\n */\nfunction arrayBufferToBase64(buffer: ArrayBuffer): string {\n    const bytes = new Uint8Array(buffer)\n    let binary = \"\"\n    for (let i = 0; i < bytes.byteLength; i++) {\n        binary += String.fromCharCode(bytes[i])\n    }\n    return window.btoa(binary).replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\")\n}\n\n/**\n * Convert a base64url string to Uint8Array\n */\nexport function base64UrlToUint8Array(base64Url: string): Uint8Array {\n    const padding = '='.repeat((4 - (base64Url.length % 4)) % 4)\n    const base64 = (base64Url + padding).replace(/-/g, '+').replace(/_/g, '/')\n    const rawData = atob(base64)\n    const outputArray = new Uint8Array(rawData.length)\n    for (let i = 0; i < rawData.length; ++i) {\n        outputArray[i] = rawData.charCodeAt(i)\n    }\n    return outputArray\n}\n\n/**\n * Check if WebAuthn is supported in the current browser\n */\nexport function isWebAuthnSupported(): boolean {\n    return typeof window !== 'undefined' &&\n        typeof window.PublicKeyCredential !== 'undefined' &&\n        typeof navigator.credentials !== 'undefined' &&\n        typeof navigator.credentials.create !== 'undefined' &&\n        typeof navigator.credentials.get !== 'undefined'\n}\n\n/**\n * Authenticate with biometrics using WebAuthn\n */\nexport async function authenticateWithBiometrics(): Promise<boolean> {\n    try {\n        // In a real application, this would be fetched from your server\n        // The server would generate a random challenge for security\n        const mockAuthenticationOptions: PublicKeyCredentialRequestOptions = {\n            challenge: new Uint8Array([\n                21, 31, 105, 25, 8, 175, 238, 100, 55, 69, 37, 79, 138, 42, 5, 128, 28, 38, 93, 143, 85, 196, 125, 94, 242, 27,\n                211, 33, 88, 55, 41, 73,\n            ]),\n            timeout: 60000,\n            rpId: window.location.hostname,\n            userVerification: \"preferred\",\n            // In a real app, this would include the user's registered credentials\n            allowCredentials: [],\n        }\n\n        // Start the authentication process\n        const credential = (await navigator.credentials.get({\n            publicKey: {\n                ...mockAuthenticationOptions,\n                allowCredentials: mockAuthenticationOptions.allowCredentials as PublicKeyCredentialDescriptor[]\n            },\n        })) as PublicKeyCredential\n\n        if (!credential) {\n            throw new Error(\"No credentials returned\")\n        }\n\n        // In a real application, you would send this response to your server for verification\n        const authenticatorData = credential.response as AuthenticatorAssertionResponse\n\n        // For demo purposes, we'll just log the credential ID\n        console.log(\"Authentication successful with credential ID:\", arrayBufferToBase64(credential.rawId))\n\n        // In a real app, you would verify the assertion with your server\n        // const verificationResponse = await fetch('/api/auth/verify-assertion', {\n        //   method: 'POST',\n        //   headers: { 'Content-Type': 'application/json' },\n        //   body: JSON.stringify({\n        //     id: arrayBufferToBase64(credential.rawId),\n        //     rawId: arrayBufferToBase64(credential.rawId),\n        //     type: credential.type,\n        //     response: {\n        //       authenticatorData: arrayBufferToBase64(authenticatorData.authenticatorData),\n        //       clientDataJSON: arrayBufferToBase64(authenticatorData.clientDataJSON),\n        //       signature: arrayBufferToBase64(authenticatorData.signature),\n        //       userHandle: authenticatorData.userHandle ? arrayBufferToBase64(authenticatorData.userHandle) : null\n        //     }\n        //   })\n        // })\n\n        // Return success\n        return true\n    } catch (error) {\n        console.error(\"WebAuthn authentication error:\", error)\n        throw error\n    }\n}\n\n/**\n * Register a new biometric credential (for reference, not used in the login component)\n */\nexport async function registerBiometricCredential(username: string): Promise<boolean> {\n    try {\n        // In a real application, this would be fetched from your server\n        const userId = new Uint8Array(16)\n        window.crypto.getRandomValues(userId)\n\n        const mockCreationOptions = {\n            challenge: new Uint8Array([\n                21, 31, 105, 25, 8, 175, 238, 100, 55, 69, 37, 79, 138, 42, 5, 128, 28, 38, 93, 143, 85, 196, 125, 94, 242, 27,\n                211, 33, 88, 55, 41, 73,\n            ]),\n            rp: {\n                name: \"Your Application\",\n                id: window.location.hostname,\n            },\n            user: {\n                id: userId,\n                name: username,\n                displayName: username,\n            },\n            pubKeyCredParams: [\n                { type: \"public-key\", alg: -7 }, // ES256\n                { type: \"public-key\", alg: -257 }, // RS256\n            ],\n            timeout: 60000,\n            attestation: \"none\",\n            authenticatorSelection: {\n                authenticatorAttachment: \"platform\",\n                userVerification: \"preferred\",\n            },\n        }\n\n        // Start the registration process\n        const credential = (await navigator.credentials.create({\n            publicKey: mockCreationOptions as PublicKeyCredentialCreationOptions,\n        })) as PublicKeyCredential\n\n        if (!credential) {\n            throw new Error(\"No credentials returned\")\n        }\n\n        // In a real application, you would send this response to your server\n        console.log(\"Registration successful with credential ID:\", arrayBufferToBase64(credential.rawId))\n\n        return true\n    } catch (error) {\n        console.error(\"WebAuthn registration error:\", error)\n        throw error\n    }\n}\n\n/**\n * Handle registration with biometrics\n */\nexport async function handleRegistration(\n    registerUrl: string,\n    verifyUrl: string,\n    username: string,\n    onStatusChange?: (status: AuthenticationStatus) => void,\n    onRegistrationSuccess?: (credential: Credential | null) => void,\n    onError?: (error: Error) => void\n): Promise<void> {\n    try {\n        onStatusChange?.(\"authenticating\")\n\n        const response = await fetch(registerUrl, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({ username })\n        })\n\n        if (!response.ok) throw new Error(\"Failed to get registration options\")\n\n        const options = await response.json()\n\n        const credential = await navigator.credentials.create({\n            publicKey: {\n                ...options,\n                challenge: base64UrlToUint8Array(options.challenge),\n                user: {\n                    ...options.user,\n                    id: base64UrlToUint8Array(options.user.id)\n                }\n            }\n        })\n\n        if (!credential) throw new Error(\"Failed to create credential\")\n\n        const verifyResponse = await fetch(verifyUrl, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                credential,\n                type: \"registration\"\n            })\n        })\n\n        if (!verifyResponse.ok) throw new Error(\"Failed to verify credential\")\n\n        onStatusChange?.(\"success\")\n        onRegistrationSuccess?.(credential)\n    } catch (error) {\n        const err = error instanceof Error ? error : new Error(\"Registration failed\")\n        onStatusChange?.(\"error\")\n        onError?.(err)\n        throw err\n    }\n}\n\n/**\n * Handle authentication with biometrics\n */\nexport async function handleAuthentication(\n    authenticateUrl: string,\n    verifyUrl: string,\n    username: string,\n    onStatusChange?: (status: AuthenticationStatus) => void,\n    onAuthenticationSuccess?: (credential: Credential | null) => void,\n    onError?: (error: Error) => void\n): Promise<void> {\n    try {\n        onStatusChange?.(\"authenticating\")\n\n        const response = await fetch(authenticateUrl, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({ username })\n        })\n\n        if (!response.ok) throw new Error(\"Failed to get authentication options\")\n\n        const options = await response.json()\n\n        const credential = await navigator.credentials.get({\n            publicKey: {\n                ...options,\n                challenge: base64UrlToUint8Array(options.challenge)\n            }\n        })\n\n        if (!credential) throw new Error(\"Failed to get credential\")\n\n        const verifyResponse = await fetch(verifyUrl, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                credential,\n                type: \"authentication\"\n            })\n        })\n\n        if (!verifyResponse.ok) throw new Error(\"Failed to verify credential\")\n\n        onStatusChange?.(\"success\")\n        onAuthenticationSuccess?.(credential)\n    } catch (error) {\n        const err = error instanceof Error ? error : new Error(\"Authentication failed\")\n        onStatusChange?.(\"error\")\n        onError?.(err)\n        throw err\n    }\n}\n",
      "type": "registry:lib"
    }
  ]
}